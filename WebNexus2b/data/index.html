<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP-01 Data Visualization</title>
    <script src="/Chart.min.js"></script>
    <script>
        // Polyfill per Array.prototype.fill
        if (!Array.prototype.fill) {
            Object.defineProperty(Array.prototype, 'fill', {
                value: function(value) {
                    if (this == null) {
                        throw new TypeError('this is null or not defined');
                    }
                    var O = Object(this);
                    var len = O.length >>> 0;
                    var start = arguments[1];
                    var relativeStart = start >> 0;
                    var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
                    var end = arguments[2];
                    var relativeEnd = end === undefined ? len : end >> 0;
                    var final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
                    while (k < final) {
                        O[k] = value;
                        k++;
                    }
                    return O;
                }
            });
        }

        // Polyfill per Array.prototype.forEach
        if (!Array.prototype.forEach) {
            Array.prototype.forEach = function(callback, thisArg) {
                var T, k;
                if (this == null) {
                    throw new TypeError('this is null or not defined');
                }
                var O = Object(this);
                var len = O.length >>> 0;
                if (typeof callback !== 'function') {
                    throw new TypeError(callback + ' is not a function');
                }
                if (arguments.length > 1) {
                    T = thisArg;
                }
                k = 0;
                while (k < len) {
                    var kValue;
                    if (k in O) {
                        kValue = O[k];
                        callback.call(T, kValue, k, O);
                    }
                    k++;
                }
            };
        }
    </script>
</head>
<body>
    <canvas id="myChart" width="400" height="200"></canvas>
    <script>
        var ctx = document.getElementById('myChart').getContext('2d');
        var data = {
            labels: new Array(31).fill(''),
            datasets: [
                {
                    label: 'Active Diff',
                    backgroundColor: 'rgba(255, 99, 132, 0.2)',
                    borderColor: 'rgba(255, 99, 132, 1)',
                    borderWidth: 1,
                    data: new Array(31).fill(0)
                },
                {
                    label: 'Reactive Diff',
                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    borderWidth: 1,
                    data: new Array(31).fill(0)
                },
                {
                    label: 'Intensita Luminosa',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    borderColor: 'rgba(75, 192, 192, 1)',
                    borderWidth: 1,
                    data: new Array(31).fill(0)
                }
            ]
        };

        var config = {
            type: 'bar',
            data: data,
            options: {
                responsive: true,
                scales: {
                    xAxes: [{
                        stacked: true
                    }],
                    yAxes: [{
                        stacked: true
                    }]
                }
            }
        };

        var myChart = new Chart(ctx, config);

        var websocket = new WebSocket('ws://' + location.hostname + ':81/');

        websocket.onopen = function() {
            console.log('WebSocket connection established');
            websocket.send('getData');
        };

        websocket.onmessage = function(event) {
            var message = JSON.parse(event.data);
            if (Object.prototype.toString.call(message) === '[object Array]') {
                for (var i = message.length - 1; i >= 0; i--) {
                    var dataPoint = message[i];
                    var date = new Date(dataPoint.timestamp * 1000);
                    var formattedTime = date.getHours() + ':' + date.getMinutes() + ':' + date.getSeconds();
                    myChart.data.labels[31 - (message.length - 1 - i) - 1] = formattedTime;
                    myChart.data.datasets[0].data[31 - (message.length - 1 - i) - 1] = dataPoint.activeDiff;
                    myChart.data.datasets[1].data[31 - (message.length - 1 - i) - 1] = dataPoint.reactiveDiff;
                    myChart.data.datasets[2].data[31 - (message.length - 1 - i) - 1] = dataPoint.intensitaLuminosa;
                    // Puoi utilizzare dataPoint.timeDiff qui se necessario
                    console.log('TimeDiff:', dataPoint.timeDiff);
                }
            } else {
                var date = new Date(message.timestamp * 1000);
                var formattedTime = date.getHours() + ':' + date.getMinutes() + ':' + date.getSeconds();
                myChart.data.labels.unshift(formattedTime);
                myChart.data.datasets[0].data.unshift(message.activeDiff);
                myChart.data.datasets[1].data.unshift(message.reactiveDiff);
                myChart.data.datasets[2].data.unshift(message.intensitaLuminosa);
                // Puoi utilizzare message.timeDiff qui se necessario
                console.log('TimeDiff:', message.timeDiff);

                if (myChart.data.labels.length > 31) {
                    myChart.data.labels.pop();
                    myChart.data.datasets.forEach(function(dataset) {
                        dataset.data.pop();
                    });
                }
            }
            myChart.update();
        };

        websocket.onclose = function() {
            console.log('WebSocket connection closed');
        };
    </script>
</body>
</html>
