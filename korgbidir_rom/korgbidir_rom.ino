/*
 * Korg EX-800 – Unico sketch:
 * - CAPTURE: chiede il dump e stampa tutti i byte "dopo F0" (senza checksum/F7).
 * - WRITE: invia RAM DATA completo da PROGMEM sostituendo la Voice 11 con valori da variabili "umane".
 *
 * HW: MIDI IN (optocoupler) -> D8 (RX), MIDI OUT (DIN pin 5 via 220Ω) -> D9 (TX)
 */

#include <Arduino.h>
#include <SoftwareSerial.h>
#include <avr/pgmspace.h>

// ==================== Selezione modalità ====================
#define MODE_CAPTURE false   // true = cattura dump; false = scrivi RAM DATA con voice 11 sostituita

// ==================== MIDI ====================
#define MIDI_RX_PIN 8
#define MIDI_TX_PIN 9
SoftwareSerial midi(MIDI_RX_PIN, MIDI_TX_PIN); // RX, TX

// ==================== Costanti Korg/EX-800 ====================
static const uint8_t KORG_ID      = 0x42;
static const uint8_t DEVICE_BYTE  = 0x21;
static const uint8_t MODEL_BYTE   = 0x01;
static const uint8_t FUNC_RAMDATA = 0x00;   // RAM DATA (bulk write)

// Offset NIBBLE della voice 0 (Program 11) dentro al SysEx (contando dal byte dopo F0, con 0x42 all'indice 1)
static const uint16_t VOICES_START = 0x0244; // come da tuo lavoro
static const uint8_t  VOICE_LEN    = 21;     // 21 byte per voice
static const uint16_t NEED_NIBBLES = VOICE_LEN * 2;

// Indici utili
static const uint16_t VOICE0_NIB_START_IDX0 = VOICES_START - 1; // 0-based dal 0x42
static const uint16_t DATA_START_IDX0       = 4;                // dopo header 42 21 01 00

// ==================== Strutture "umane" ====================
struct Env { uint8_t attack, decay, brk, sustain, slope, release; };
struct DCO_t { uint8_t octave, waveform, level, harmonics; Env env; };
struct VCF_t { uint8_t cutoff, resonance, kbdTrack, polarity, egIntensity, trigger; Env env; };
struct MG_t  { uint8_t freq, delay, dco, vcf; };
struct VoiceDecoded {
  DCO_t dco1, dco2;
  uint8_t dcoMode, dcoInterval, dcoDetune;
  VCF_t vcf;
  MG_t  mg;
  uint8_t noise, chorus;
};

// ---------------- prototipi encode/decode ----------------
void decodeVoice(const uint8_t v[VOICE_LEN], VoiceDecoded &o);
void encodeVoice(const VoiceDecoded &o, uint8_t v[VOICE_LEN]);

// ==================== I/O SysEx utili ====================
void sendDumpRequest() {
  const uint8_t req[] = { 0xF0, 0x42, 0x21, 0x01, 0x10, 0xF7 };
  midi.write(req, sizeof(req));
  midi.flush();
  Serial.println(F(">> Richiesta BULK DUMP inviata"));
}

// Checksum Korg 7-bit su tutti i “data” (dopo i 4 header bytes)
static inline uint8_t korg_checksum7(uint8_t sum7) {
  return (uint8_t)((0x80 - (sum7 & 0x7F)) & 0x7F);
}

// ==================== CAPTURE MODE ====================
#if MODE_CAPTURE

void setup() {
  Serial.begin(115200);
  midi.begin(31250);
  delay(250);

  Serial.println(F("\n=== CAPTURE MODE ==="));
  sendDumpRequest();
}

void loop() {
  static bool inSysex = false;
  static uint32_t idx = 0;       // 1-based (42 = idx 1)
  static uint8_t prev = 0;
  static uint8_t sum7 = 0;
  static uint8_t col  = 0;

  while (midi.available()) {
    uint8_t b = midi.read();

    if (!inSysex) {
      if (b == 0xF0) {
        inSysex = true;
        idx = 0; sum7 = 0; col = 0;
        Serial.println(F("\n// COPIA E INCOLLA qui sotto in PROGMEM (ESCLUDI checksum e F7)"));
        Serial.println(F("// Inizio dopo F0:"));
      }
      continue;
    }

    if (b == 0xF7) {
      uint8_t expected = korg_checksum7(sum7);
      Serial.println();
      Serial.print(F("// Checksum ricevuto: 0x")); Serial.print(prev, HEX);
      Serial.print(F(" | Calcolato: 0x")); Serial.println(expected, HEX);
      Serial.println(F("// Se combaciano, incolla i byte stampati sopra nell'array PROGMEM della WRITE MODE."));
      inSysex = false;
      continue;
    }

    // stampa
    Serial.print(F("0x"));
    if (b < 0x10) Serial.print('0');
    Serial.print(b, HEX);
    Serial.print(F(", "));
    if (++col == 16) { Serial.println(); col = 0; }

    prev = b;
    idx++;
    if (idx > DATA_START_IDX0) sum7 = (uint8_t)((sum7 + (b & 0x7F)) & 0x7F);
  }
}

#else
// ==================== WRITE MODE ====================

/*
 * Incolla qui sotto TUTTI i byte DOPO F0 (senza checksum e senza F7).
 * DEVE iniziare con: 0x42, 0x21, 0x01, 0x00, ...
 */
const uint8_t PROGMEM EX800_RAM_AFTER_F0[] = {
  // >>> INCOLLA IL TUO DUMP QUI (quello che hai messo nel messaggio va bene per test) <<<
  //0x42,0x21,0x01,0x00,
  // --- ATTENZIONE: riempi davvero tutto il dump qui. Sotto ho lasciato un placeholder minimo ---
  // Usa il tuo blocco "0x00, ..." + i dati reali, come già hai fatto.
  // Per brevità in questo esempio tengo pochi byte, ma tu DEVI incollare l'intero contenuto.
  //0x00,0x00,0x00,0x00,0x00,0x00, // <--- Sostituisci con il dump completo!
  // Inizio dopo F0: 
  0x42, 0x21, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x06, 0x0A, 0x0E, 0x01, 0x0B, 0x08, 0x0F, 0x0F, 0x00, 0x06, 0x00, 0x0F, 0x06, 0x00, 0x0E, 0x00, 
  0x01, 0x00, 0x00, 0x0A, 0x0F, 0x00, 0x02, 0x00, 0x00, 0x0F, 0x0B, 0x08, 0x0C, 0x08, 0x0F, 0x05, 
  0x0B, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0A, 0x02, 0x09, 0x0D, 0x00, 0x0F, 0x07, 0x0F, 0x03, 
  0x0C, 0x0A, 0x00, 0x05, 0x0F, 0x00, 0x08, 0x01, 0x0F, 0x00, 0x05, 0x0A, 0x00, 0x05, 0x09, 0x01, 
  0x0F, 0x01, 0x00, 0x00, 0x08, 0x08, 0x0F, 0x00, 0x03, 0x00, 0x08, 0x0B, 0x0B, 0x01, 0x0B, 0x01, 
  0x0F, 0x00, 0x0E, 0x01, 0x00, 0x0B, 0x00, 0x07, 0x0C, 0x08, 0x0E, 0x00, 0x07, 0x00, 0x05, 0x03, 
  0x04, 0x0C, 0x03, 0x0D, 0x0F, 0x00, 0x0A, 0x08, 0x06, 0x01, 0x00, 0x08, 0x06, 0x02, 0x0F, 0x04, 
  0x03, 0x08, 0x0E, 0x05, 0x0B, 0x0A, 0x02, 0x09, 0x05, 0x04, 0x05, 0x01, 0x00, 0x0F, 0x00, 0x0F, 
  0x07, 0x00, 0x05, 0x00, 0x0F, 0x00, 0x0E, 0x0F, 0x0B, 0x08, 0x0B, 0x09, 0x05, 0x04, 0x05, 0x07, 
  0x00, 0x0E, 0x08, 0x03, 0x08, 0x04, 0x0A, 0x02, 0x07, 0x00, 0x06, 0x0F, 0x01, 0x03, 0x02, 0x01, 
  0x0E, 0x00, 0x00, 0x07, 0x00, 0x0F, 0x08, 0x0B, 0x0A, 0x0A, 0x05, 0x04, 0x08, 0x07, 0x00, 0x00, 
  0x05, 0x00, 0x05, 0x07, 0x02, 0x08, 0x03, 0x05, 0x0E, 0x00, 0x0B, 0x00, 0x09, 0x0A, 0x00, 0x00, 
  0x05, 0x00, 0x04, 0x0F, 0x00, 0x00, 0x00, 0x06, 0x0F, 0x00, 0x04, 0x04, 0x06, 0x0F, 0x0F, 0x00, 
  0x00, 0x08, 0x0F, 0x00, 0x00, 0x08, 0x00, 0x0D, 0x0A, 0x07, 0x0F, 0x0A, 0x0F, 0x00, 0x0F, 0x04, 
  0x0E, 0x03, 0x00, 0x0A, 0x00, 0x0A, 0x0F, 0x00, 0x0A, 0x08, 0x00, 0x04, 0x07, 0x07, 0x03, 0x04, 
  0x0F, 0x00, 0x04, 0x00, 0x05, 0x00, 0x07, 0x00, 0x00, 0x05, 0x0F, 0x00, 0x02, 0x06, 0x00, 0x01, 
  0x00, 0x0E, 0x00, 0x08, 0x0F, 0x06, 0x0F, 0x00, 0x06, 0x04, 0x06, 0x00, 0x0C, 0x05, 0x0F, 0x0C, 
  0x05, 0x00, 0x0E, 0x03, 0x00, 0x08, 0x02, 0x0A, 0x03, 0x00, 0x00, 0x08, 0x00, 0x00, 0x07, 0x00, 
  0x0C, 0x00, 0x0F, 0x00, 0x03, 0x04, 0x06, 0x0F, 0x0F, 0x07, 0x00, 0x00, 0x05, 0x04, 0x08, 0x07, 
  0x0F, 0x0B, 0x07, 0x09, 0x0F, 0x06, 0x0F, 0x00, 0x02, 0x04, 0x0E, 0x0A, 0x0B, 0x0F, 0x08, 0x0A, 
  0x0E, 0x00, 0x00, 0x07, 0x0D, 0x0F, 0x0C, 0x0F, 0x00, 0x0A, 0x0A, 0x02, 0x00, 0x04, 0x00, 0x0C, 
  0x0B, 0x0A, 0x00, 0x00, 0x0F, 0x00, 0x03, 0x08, 0x07, 0x0F, 0x03, 0x0F, 0x00, 0x00, 0x00, 0x07, 
  0x05, 0x07, 0x00, 0x0E, 0x08, 0x03, 0x09, 0x01, 0x04, 0x0C, 0x02, 0x08, 0x02, 0x00, 0x02, 0x0D, 
  0x00, 0x02, 0x05, 0x04, 0x07, 0x04, 0x00, 0x08, 0x06, 0x00, 0x00, 0x00, 0x04, 0x0E, 0x00, 0x0C, 
  0x09, 0x00, 0x0A, 0x03, 0x01, 0x0C, 0x05, 0x04, 0x07, 0x04, 0x00, 0x0D, 0x02, 0x0F, 0x0C, 0x05, 
  0x06, 0x02, 0x03, 0x03, 0x03, 0x0B, 0x09, 0x06, 0x00, 0x00, 0x0A, 0x01, 0x0C, 0x01, 0x03, 0x05, 
  0x08, 0x00, 0x06, 0x04, 0x0A, 0x02, 0x0F, 0x05, 0x00, 0x03, 0x01, 0x00, 0x04, 0x00, 0x09, 0x04, 
  0x0B, 0x0B, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0x0F, 0x00, 0x00, 0x0F, 0x05, 0x0F, 
  0x04, 0x0C, 0x08, 0x0F, 0x02, 0x04, 0x04, 0x0E, 0x05, 0x0B, 0x0A, 0x08, 0x06, 0x05, 0x00, 0x01, 
  0x00, 0x0F, 0x05, 0x0F, 0x04, 0x0C, 0x08, 0x0F, 0x00, 0x04, 0x02, 0x00, 0x0F, 0x0D, 0x01, 0x00, 
  0x0E, 0x0F, 0x0C, 0x0F, 0x0B, 0x00, 0x0F, 0x08, 0x0F, 0x0E, 0x0F, 0x05, 0x00, 0x07, 0x09, 0x0E, 
  0x0B, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x08, 0x06, 0x01, 0x01, 0x05, 0x00, 0x0C, 0x0E, 0x04, 
  0x04, 0x0F, 0x09, 0x00, 0x08, 0x0C, 0x0C, 0x03, 0x08, 0x04, 0x0C, 0x07, 0x0E, 0x00, 0x0F, 0x00, 
  0x02, 0x00, 0x03, 0x0A, 0x02, 0x00, 0x0A, 0x00, 0x06, 0x08, 0x06, 0x0A, 0x0D, 0x05, 0x0F, 0x0F, 
  0x02, 0x00, 0x0C, 0x05, 0x00, 0x0C, 0x0A, 0x0A, 0x02, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 
  0x0A, 0x02, 0x03, 0x00, 0x06, 0x00, 0x07, 0x0C, 0x00, 0x00, 0x00, 0x04, 0x0F, 0x00, 0x02, 0x00, 
  0x0F, 0x01, 0x00, 0x00, 0x00, 0x02, 0x09, 0x0A, 0x00, 0x07, 0x00, 0x00, 0x0C, 0x0F, 0x00, 0x00, 
  0x0F, 0x00, 0x0E, 0x00, 0x0A, 0x0C, 0x0E, 0x07, 0x0D, 0x03, 0x0A, 0x00, 0x0F, 0x04, 0x00, 0x00, 
  0x0E, 0x05, 0x05, 0x00, 0x02, 0x00, 0x07, 0x00, 0x02, 0x00, 0x0C, 0x04, 0x08, 0x08, 0x09, 0x0D, 
  0x04, 0x08, 0x0A, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x0C, 0x0A, 0x07, 0x0F, 0x0F, 0x0F, 0x05, 
  0x00, 0x08, 0x0D
};
static const uint32_t EX800_LEN_AFTER_F0 = sizeof(EX800_RAM_AFTER_F0);

// -------- VoiceDecoded “di partenza” (puoi cambiare questi valori) --------
VoiceDecoded dec = [](){
  VoiceDecoded v{};
  // Alcune scelte ragionevoli per test (modifica a piacere):
  v.dcoMode = 0;            // 0=Whole, 1=Double
  v.dcoInterval = 7;        // quinta
  v.dcoDetune  = 1;
  v.chorus     = 1;         // On
  v.noise      = 0;

  v.dco1.octave=1; v.dco1.waveform=1; v.dco1.level=24; v.dco1.harmonics=0x0; // Saw, livello medio
  v.dco2.octave=1; v.dco2.waveform=1; v.dco2.level=22; v.dco2.harmonics=0x0;

  v.vcf.cutoff=70; v.vcf.resonance=4; v.vcf.kbdTrack=2; v.vcf.polarity=1; v.vcf.egIntensity=8; v.vcf.trigger=1;

  v.mg.freq=4; v.mg.delay=2; v.mg.dco=0; v.mg.vcf=2;

  // ENV di esempio (puoi impostarle come preferisci: range già coerenti con packing)
  v.dco1.env = {10,12,8,10,5,9};
  v.dco2.env = {10,12,8,10,5,9};
  v.vcf.env  = {12,12,4,10,6,8};
  return v;
}();

// Compatta i 21 byte da `dec`
uint8_t newVoice21[VOICE_LEN];

// -------------------- Invio RAM DATA completo con voice 11 sovrascritta --------------------
void sendRamWithVoice11Override(const uint8_t voice[VOICE_LEN]) {
  if (EX800_LEN_AFTER_F0 < (VOICE0_NIB_START_IDX0 + NEED_NIBBLES)) {
    Serial.println(F("** ERRORE: PROGMEM troppo corto o offset errato."));
    return;
  }

  // Sanity header
  uint8_t h0 = pgm_read_byte(EX800_RAM_AFTER_F0 + 0);
  uint8_t h1 = pgm_read_byte(EX800_RAM_AFTER_F0 + 1);
  uint8_t h2 = pgm_read_byte(EX800_RAM_AFTER_F0 + 2);
  uint8_t h3 = pgm_read_byte(EX800_RAM_AFTER_F0 + 3);
  if (h0 != KORG_ID || h1 != DEVICE_BYTE || h2 != MODEL_BYTE || h3 != FUNC_RAMDATA) {
    Serial.println(F("** ATTENZIONE: header non è 42 21 01 00."));
  }

  Serial.println(F(">> Invio RAM DATA completo con Voice 11 sostituita..."));

  midi.write(0xF0);
  uint8_t sum7 = 0;

  // 1) Prima della voice
  for (uint32_t i = 0; i < VOICE0_NIB_START_IDX0; ++i) {
    uint8_t b = pgm_read_byte(EX800_RAM_AFTER_F0 + i);
    midi.write(b);
    if (i >= DATA_START_IDX0) sum7 = (uint8_t)((sum7 + (b & 0x7F)) & 0x7F);
  }

  // 2) I 42 nibble LSB→MSB della nuova voice
  for (uint8_t j = 0; j < VOICE_LEN; ++j) {
    uint8_t v = voice[j];
    uint8_t l = v & 0x0F;
    uint8_t m = (v >> 4) & 0x0F;
    midi.write(l); sum7 = (uint8_t)((sum7 + l) & 0x7F);
    midi.write(m); sum7 = (uint8_t)((sum7 + m) & 0x7F);
  }

  // 3) Dal dopo-voice fino alla fine (esclusi checksum originale e F7)
  for (uint32_t i = VOICE0_NIB_START_IDX0 + NEED_NIBBLES; i < EX800_LEN_AFTER_F0; ++i) {
    uint8_t b = pgm_read_byte(EX800_RAM_AFTER_F0 + i);
    midi.write(b);
    if (i >= DATA_START_IDX0) sum7 = (uint8_t)((sum7 + (b & 0x7F)) & 0x7F);
  }

  // 4) Checksum nuovo + F7
  uint8_t chksum = korg_checksum7(sum7);
  midi.write(chksum);
  midi.write(0xF7);
  midi.flush();

  Serial.print(F(">> Fatto. Checksum calcolato: 0x"));
  Serial.println(chksum, HEX);
}

// ==================== ENCODE/DECODE IMPLEMENTAZIONI ====================
void decodeVoice(const uint8_t v[VOICE_LEN], VoiceDecoded &o) {
  o.dco1.octave   = (v[0] >> 0) & 0x03;
  o.dco2.octave   = (v[0] >> 2) & 0x03;
  o.dco1.waveform = (v[0] >> 4) & 0x03;
  o.dco2.waveform = (v[0] >> 6) & 0x03;
  o.dco1.harmonics = (v[1] >> 0) & 0x0F;
  o.dco2.harmonics = (v[1] >> 4) & 0x0F;
  o.dcoDetune = (v[2] >> 0) & 0x03;
  o.dcoMode   = (v[2] >> 6) & 0x01;                 // 0=Whole,1=Double
  o.chorus    = ((v[2] >> 7) == 0) ? 1 : 0;         // 1=On, 0=Off
  o.dcoInterval = (v[3] >> 0) & 0x0F;
  o.noise       = (v[3] >> 4) & 0x0F;
  o.vcf.egIntensity = (v[4] >> 0) & 0x0F;
  o.vcf.polarity    = ((v[4] >> 4) & 0x01) ? 1 : 0;
  o.dco1.level      = ((v[4] >> 5) & 0x07) << 2;
  o.dco1.level     |= (v[5] & 0x03);
  o.dco2.level      = (v[5] >> 2) & 0x1F;
  o.vcf.cutoff  = v[6] & 0x7F;
  o.vcf.trigger = (v[6] >> 7) & 0x01;
  o.mg.freq  = (v[7] >> 0) & 0x0F;
  o.mg.delay = (v[7] >> 4) & 0x0F;
  o.mg.dco = (v[8] >> 0) & 0x0F;
  o.mg.vcf = (v[8] >> 4) & 0x0F;

  // DCO1 ENV
  o.dco1.env.attack  = (v[9]  >> 0) & 0x1F;
  o.dco1.env.decay   = (v[9]  >> 5) & 0x07;
  o.dco1.env.decay  |= (v[10] & 0x03) << 3;
  o.dco1.env.brk     = (v[10] >> 2) & 0x1F;
  o.dco1.env.slope   = (v[10] >> 7) & 0x01;
  o.dco1.env.slope  |= (v[11] & 0x0F) << 1;
  o.dco1.env.sustain = (v[11] >> 4) & 0x0F;
  o.dco1.env.sustain|= (v[12] & 0x01) << 4;
  o.dco1.env.release = (v[12] >> 1) & 0x1F;

  // DCO2 ENV
  o.dco2.env.attack  = (v[12] >> 6) & 0x03;
  o.dco2.env.attack |= (v[13] & 0x07) << 2;
  o.dco2.env.decay   = (v[13] >> 3) & 0x1F;
  o.dco2.env.brk     = (v[14] >> 0) & 0x1F;
  o.dco2.env.slope   = (v[14] >> 5) & 0x07;
  o.dco2.env.slope  |= (v[15] & 0x03) << 3;
  o.dco2.env.sustain = (v[15] >> 2) & 0x1F;
  o.dco2.env.release = (v[15] >> 7) & 0x01;
  o.dco2.env.release|= (v[16] & 0x0F) << 1;

  // VCF ENV
  o.vcf.env.attack  = (v[16] >> 4) & 0x0F;
  o.vcf.env.attack |= (v[17] & 0x01) << 4;
  o.vcf.env.decay   = (v[17] >> 1) & 0x1F;
  o.vcf.env.brk     = (v[17] >> 6) & 0x03;
  o.vcf.env.brk    |= (v[18] & 0x07) << 2;
  o.vcf.env.slope   = (v[18] >> 3) & 0x1F;
  o.vcf.env.sustain = (v[19] >> 0) & 0x1F;
  o.vcf.env.release = (v[19] >> 5) & 0x07;
  o.vcf.env.release|= (v[20] & 0x03) << 3;

  o.vcf.resonance   = (v[20] >> 2) & 0x0F;
  o.vcf.kbdTrack    = (v[20] >> 6) & 0x03;
}

void encodeVoice(const VoiceDecoded &o, uint8_t v[VOICE_LEN]) {
  memset(v, 0, VOICE_LEN);
  v[0] |= (o.dco1.octave & 0x03) << 0;
  v[0] |= (o.dco2.octave & 0x03) << 2;
  v[0] |= (o.dco1.waveform & 0x03) << 4;
  v[0] |= (o.dco2.waveform & 0x03) << 6;
  v[1] |= (o.dco1.harmonics & 0x0F) << 0;
  v[1] |= (o.dco2.harmonics & 0x0F) << 4;
  v[2] |= (o.dcoDetune & 0x03) << 0;
  v[2] |= (o.dcoMode & 0x01) << 6;
  v[2] |= ((o.chorus ? 0 : 1) & 0x01) << 7; // 0=ON,1=OFF (inverso)
  v[3] |= (o.dcoInterval & 0x0F) << 0;
  v[3] |= (o.noise       & 0x0F) << 4;
  v[4] |= (o.vcf.egIntensity & 0x0F) << 0;
  v[4] |= (o.vcf.polarity    ? 1 : 0) << 4;
  v[4] |= ((o.dco1.level >> 2) & 0x07) << 5;
  v[5] |= (o.dco1.level & 0x03) << 0;
  v[5] |= (o.dco2.level & 0x1F) << 2;
  v[6] |= (o.vcf.cutoff & 0x7F) << 0;
  v[6] |= (o.vcf.trigger & 0x01) << 7;
  v[7] |= (o.mg.freq  & 0x0F) << 0;
  v[7] |= (o.mg.delay & 0x0F) << 4;
  v[8] |= (o.mg.dco & 0x0F) << 0;
  v[8] |= (o.mg.vcf & 0x0F) << 4;

  // DCO1 ENV
  v[9]  |= (o.dco1.env.attack & 0x1F) << 0;
  v[9]  |= (o.dco1.env.decay  & 0x07) << 5;
  v[10] |= ((o.dco1.env.decay >> 3) & 0x03) << 0;
  v[10] |= (o.dco1.env.brk    & 0x1F) << 2;
  v[10] |= (o.dco1.env.slope  & 0x01) << 7;
  v[11] |= ((o.dco1.env.slope >> 1) & 0x0F) << 0;
  v[11] |= (o.dco1.env.sustain & 0x0F) << 4;
  v[12] = (v[12] & 0xC0) | ((o.dco1.env.sustain >> 4) & 0x01) | ((o.dco1.env.release & 0x1F) << 1);

  // DCO2 ENV
  v[12] = (v[12] & 0x3F) | ((o.dco2.env.attack & 0x03) << 6);
  v[13] |= ((o.dco2.env.attack >> 2) & 0x07) << 0;
  v[13] |= (o.dco2.env.decay & 0x1F) << 3;
  v[14] |= (o.dco2.env.brk   & 0x1F) << 0;
  v[14] |= (o.dco2.env.slope & 0x07) << 5;
  v[15] |= ((o.dco2.env.slope >> 3) & 0x03) << 0;
  v[15] |= (o.dco2.env.sustain & 0x1F) << 2;
  v[15] |= (o.dco2.env.release & 0x01) << 7;
  v[16] |= ((o.dco2.env.release >> 1) & 0x0F) << 0;

  // VCF ENV
  v[16] |= (o.vcf.env.attack & 0x0F) << 4;
  v[17] |= ((o.vcf.env.attack >> 4) & 0x01) << 0;
  v[17] |= (o.vcf.env.decay  & 0x1F) << 1;
  v[17] |= (o.vcf.env.brk    & 0x03) << 6;
  v[18] |= ((o.vcf.env.brk >> 2) & 0x07) << 0;
  v[18] |= (o.vcf.env.slope  & 0x1F) << 3;
  v[19] |= (o.vcf.env.sustain & 0x1F) << 0;
  v[19] |= (o.vcf.env.release & 0x07) << 5;
  v[20] |= ((o.vcf.env.release >> 3) & 0x03) << 0;

  v[20] |= (o.vcf.resonance & 0x0F) << 2;
  v[20] |= (o.vcf.kbdTrack  & 0x03) << 6;
}

// ==================== SETUP/LOOP ====================
void setup() {
  Serial.begin(115200);
  midi.begin(31250);
  delay(250);

  Serial.println(F("\n=== WRITE MODE ==="));
  Serial.print(F("Dump PROGMEM (dopo F0, senza checksum/F7): "));
  Serial.println(EX800_LEN_AFTER_F0);

  // 1) compattiamo i 21 byte voce dalle variabili "dec"
  encodeVoice(dec, newVoice21);

  // 2) inviamo RAM DATA completo con voice 11 sostituita
  sendRamWithVoice11Override(newVoice21);

  Serial.println(F(">> Inviato. Se non senti differenze, verifica offset/dump/parametri."));
}

void loop() {
  // nulla
}

#endif
